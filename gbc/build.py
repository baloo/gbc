import datetime
import git

import pickle

import os
import re
import tempfile
import shutil
import subprocess

class Builder(object):

    def __init__(self, config, repo):
        self.config = config
        self.repo = repo

    def stable(self):
        """
        Building tags, representing stable packages
        """
        targets = self.repo.stable_targets()
        git_cmd = self.repo.git_repo.git

        for i in targets:
            upstream_branch, debian_version = i

            ref = "%s debian/%s" % (upstream_branch, debian_version)
            if not self._is_build(ref):
                try:
                    debian_branch = "debian/%s" % debian_version

                    git_cmd.checkout(debian_branch)

                    output = self.config.output["stable"]

                    files = self._build(upstream_branch, debian_branch, debian_version, output, dch=False, upstream_branch=False)
                    self._publish("stable", output, files)
                finally:
                    self._mark_build(ref)


    def testing(self):
        """
        Building stable code with in development packages
        """
        targets = self.repo.testing_targets()
        git_cmd = self.repo.git_repo.git
        repo = self.repo.git_repo

        # targets represent a list of upstream tags
        # Like ['0.0.1', '0.1.0']
        for i in targets:
            debian_branch = "debian/%s-x" % i.name

            # checkout the debian branch
            git_cmd.checkout(debian_branch)

            # and get the last tag on it
            tag_describe = git_cmd.describe("--tags", "--always", "--abbrev=0", debian_branch)

            if re.match("[0-9\.]-[0-9\.]", tag_describe) is None:
                tag_describe = "%s" % tag_describe

            # Imported date will be directly in UTC \o/
            commit_date = datetime.datetime.utcfromtimestamp(i.commit.committed_date)
            commit_hash = i.commit.hexsha[0:7]

            debian_version = "%s+%s+%s" % (tag_describe, commit_date.strftime("%Y%m%d%H%M"), commit_hash)

            ref = "%s %s" % (i.name, debian_version)

            if not self._is_build(ref):
                try:
                    # for this build we will create a new temporary branch
                    # which we will build on
                    head = repo.create_head(debian_version, debian_branch)
                    debian_branch = head.checkout().name

                    output = self.config.output["testing"]
                    files = self._build(i.name, debian_branch, debian_version[7:], output, upstream_branch=False)
                    self._publish("testing", output, files)
                finally:
                    self._mark_build(ref)

    def unstable(self):
        """
        Building unstable code
        """
        targets = self.repo.unstable_targets()
        git_cmd = self.repo.git_repo.git
        repo = self.repo.git_repo

        for i in targets:
            # We'll try to get a nice tag
            tag_describe = git_cmd.describe("--tags", "--always", "--abbrev=0", i)
            # Imported date will be directly in UTC \o/
            commit_date = datetime.datetime.utcfromtimestamp(i.commit.committed_date)
            commit_hash = i.commit.hexsha[0:7]

            # We'll build in a new branch
            branch_ext = "%s.%s+%s" % (tag_describe, commit_date.strftime("%Y%m%d%H%M"), commit_hash)
            branch = "debian/%s-%s" % (i.name, branch_ext)

            ref = "%s %s" % (i.name, branch)
            if not self._is_build(ref):
                debian_version = "%s-1" % branch_ext

                # Create the branch
                head = repo.create_head(branch, "debian/%s" % i)
                head.checkout()

                # Then merge
                git_cmd.merge(i.name)

                try:
                    output = self.config.output["unstable"]
                    files = self._build(i, branch, debian_version, output)


                    self._publish("unstable", output, files)
                finally:
                    self._mark_build("%s %s" % (i.name, branch))



    def _build(self, upstream, debian, debian_version, output, dch = True, upstream_branch=True):
        print "Building %s with %s in %s" % (upstream, debian, debian_version)

        git_cmd = self.repo.git_repo.git

        # We will first create a new debian version, according to our parameters
        if dch:
            dch = "dch"
            maintainer_name = "Jenkins"
            maintainer_email = "jenkins@build-01.znx.fr"
            message = "Version generated by jenkins"
            distrib = "unstable"

            dch_options = [
              "-v", debian_version,
              "--auto-nmu", "--empty",
              "--dist", distrib,
              message]

            environ = os.environ.__dict__.copy()['data']
            environ.update({"DEBEMAIL": maintainer_email, "DEBFULLNAME": maintainer_name})

            command = subprocess.Popen([dch] + dch_options, env=environ)
            command.wait()

            # Then commit everything in git
            git_cmd.commit("-m", "auto bump version", "debian/changelog")

        # We will now build in a temp directory
        tmp_dir = tempfile.mkdtemp(prefix="gbc.")
        try:
            gbp = self.config.git['buildpackage']
            gbp_options = self.config.git['buildpackage_options'].copy()
            gbp_options.add("--git-debian-branch=%s" % debian)
            if upstream_branch:
                gbp_options.add("--git-upstream-branch=%s" % upstream)
                gbp_options.add("--git-upstream-tree=branch")
            else:
                gbp_options.add("--git-upstream-tag=%s" % upstream)
                gbp_options.add("--git-upstream-tree=tag")
            gbp_options.add("--git-ignore-branch")
            gbp_options.add("--git-export-dir=%s" % tmp_dir)

            environ = os.environ.__dict__.copy()['data']
            environ.update(self.config.git['buildpackage_environ'])

            command = subprocess.Popen([gbp] + list(gbp_options), env=environ)
            command.wait()

            # Then save the generated files
            dir_files = os.listdir(tmp_dir)
            tosave_files = set()
            valid_files = re.compile(".+\.(changes|deb|dsc|orig.tar.gz|debian.tar.gz)$")

            for i in dir_files:
                if valid_files.match(i):
                    tosave_files.add(i)

            for i in tosave_files:
                orig = os.path.join(tmp_dir, i)
                dest = os.path.join(output, i)
                shutil.copyfile(orig, dest)

            return tosave_files
        finally:
            shutil.rmtree(tmp_dir)

    def _publish(self, profile, output, items):
        """ Publish the generated files according to what specified in configuration file
        """

        # Get changes files
        changes_filter = re.compile(".*\.changes")
        changes = set()
        for i in items:
            match = changes_filter.match(i)
            if match:
                changes.add(match.group(0))

        # Publish them
        action = self.config.publish.get(profile, None)
        if action:
            real_action = action % {"home_dir": self.config.home_dir}
            try:
                command = subprocess.Popen(real_action.split(" ") + list(changes), cwd=output)
                command.wait()
            except OSError:
                print "Publish command %s has failed, it most likely doesn't exists" % real_action

    def _is_build(self, ref):
        if os.path.exists(self.config.lib_file):
            content = pickle.load(file(self.config.lib_file, "r"))
            return content.has_key(ref)
        else:
            return False

    def _mark_build(self, ref):
        if os.path.exists(self.config.lib_file):
            content = pickle.load(file(self.config.lib_file, "r"))
        else:
            content = {}

        content[ref] = True
        pickle.dump(content, file(self.config.lib_file, "w"))

# vim: ts=4 sw=4 expandtab:
